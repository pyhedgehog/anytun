<?xml version='1.0'?>
  <!DOCTYPE rfc SYSTEM 'rfcXXXX.dtd' [
       
  <!ENTITY rfc1546 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1546.xml'>
  <!ENTITY rfc3711 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml'>
  <!ENTITY rfc3068 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3068.xml'>
  <!ENTITY rfc2784 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2784.xml'>
  <!ENTITY rfc2401 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2401.xml'>
  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
  <!ENTITY rfc2003 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2003.xml'>
  <!ENTITY rfc2104 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml'>
]>
<?rfc toc='yes'?>
<rfc ipr='full3978' docName='draft-gsenger-pointner-secure-anycast-tunneling-protocol-01'>
  <front>
    <title>secure anycast tunneling protocol (SATP)</title>
    <author initials='O.G.' surname='Gsenger' fullname='Othmar Gsenger'>
      <organization></organization>
      <address>
        <postal>
          <street>Puerstingerstr 32</street>
          <city>Saalfelden</city>
          <code>5760</code>
          <country>AT</country>
        </postal>
        <phone></phone>
        <email>satp@gsenger.com</email>
        <uri>http://www.gsenger.com/satp/</uri>
      </address>
    </author>
    <author initials='C.P.' surname='Pointner' fullname='Christian Pointner'>
      <organization></organization>
      <address>
        <postal>
          <street>Wielandgasse 19</street>
          <city>Graz</city>
          <code>8010</code>
          <country>AT</country>
        </postal>
        <phone></phone>
        <email>equinox@anytun.org</email>
      </address>
    </author>

    <date month='April' year='2009' />

    <area>General</area>
    <workgroup></workgroup>
    <keyword>satp</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>secure anycast tunneling protocol</keyword>
    <keyword>anycast</keyword>
    <keyword>tunnel</keyword>
    <keyword>secure</keyword>
    <keyword>protocol</keyword>

    <abstract>
      <t>
        The secure anycast tunneling protocol (SATP) defines a protocol used for communication between any combination of unicast and anycast tunnel endpoints. It allows tunneling of every ETHER TYPE protocol (ethernet, ip ...). SATP directly includes cryptography and message authentication based on the methods used by the <xref target="RFC3711">Secure Real-time Transport Protocol(SRTP)</xref>. It can be used as an encrypted alternative to <xref target="RFC2003">IP Encapsulation within IP</xref> and <xref target="RFC2784">Generic Routing Encapsulation (GRE)</xref>. Both anycast receivers and senders are supported.
      </t>
    </abstract>
  </front>

  <middle>
    <section title='Introduction'>
      <t>
        SATP is a mixture of a generic encapsulation protocol like <xref target="RFC2784">GRE</xref> and a secure tunneling protocol as <xref target="RFC2401">IPsec</xref> in tunnel mode.  It can be used to build redundant virtual private network (VPN) connections.  It supports peer-to-peer tunnels, where tunnel endpoints can be any combination of unicast, multicast or anycast hosts, so it defines a <xref target="RFC1546">Host Anycast Service</xref>. Encryption is done per packet, so the protocol is robust against packet loss and routing changes.
To reduce header overhead, encryption techniques similar to <xref target="RFC3711">SRTP</xref> are being used.
      </t>
      <section title='Notational Conventions'>
        <t>
          The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in  <xref target="RFC2119">RFC2119</xref>.
        </t>
      </section>
    </section> 
    
    <section title="Motivation and usage scenarios">
      <t>
        This section gives an overview of possible usage scenarios. Please note that the protocols used in the figures are only examples and that SATP itself does not care about either transport protocols or encapsulated protocols. Routing is not done by SATP and each implemetation MAY choose it's own way of doing this task (e.g. using functions provided by the operating system). SATP is used only to encapsulate and encrypt data.
      </t>
      <section title="Usage scenarions">
        <section title='Tunneling from unicast hosts over anycast routers to other unicast hosts'>
          <figure anchor="tunnel_mode">
            <preamble>An example of SATP used to tunnel in a unicast client - anycast server model</preamble>
            <artwork>
                    --------- router ----------- 
                   /                            \ 
    unicast ------+---------- router ------------+------ unicast
    host           \                            /        host
                    --------- router -----------  

  unicast  | encrypted     |  anycast  | encrypted     |  unicast
  tunnel   | communication |  tunnel   | communication |  tunnel  
  endpoint | using SATP    |  endpoint | using SATP    |  endpoint 
            </artwork>
          </figure>
          <t>
            In this scenario the payload is encapsuleted into a SATP packet by a unicast host and gets transmitted to one of the anycast routers. After transmisson the packet gets decapsulated by the router. This router makes a routing descision based on the underlying protocol and transmits a new SATP package to one or more unicast hosts depending on this decision.
          </t> 
        </section>
        <section title='Tunneling from unicast hosts to anycast networks'>
          <figure anchor="open_tunnel_mode">
            <preamble>An example of SATP used to encrypt data between a unicast host and anycast networks</preamble>
            <artwork>
                       -------Router -+---- DNS Server
                      /                \ 
                     /                  --- 6to4 Router
                    /
    unicast -------+----------Router --+--- DNS Server
    host            \                   \  
                     \                   --- 6to4 Router
                      \
                       -------Router -+---- DNS Server
                                       \
                                        --- 6to4 Router

  unicast  | encrypted     |  anycast  | plaintext
  tunnel   | communication |  tunnel   | anycast
  endpoint | using SATP    |  endpoint | services

            </artwork>
          </figure>
          <t>
            When the unicast hosts wants to transmit data to one of the anycast DNS servers, it encapsulates the data and sends a SATP packet to the anycast address of the routers. The packet arrives at one of the routers, gets decapsulated and is then forwarded to the DNS server. This method can be used to tunnel between clients and networks providing anycast services. It can also be used the other way to virtually locate a unicast service within anycasted networks.
          </t>
        </section>
        <section title='Redundant tunnel connection of 2 networks'>
          <figure anchor="connect_networks">
            <preamble>An example of SATP used to connect 2 networks</preamble>
            <artwork>
              Router -----------   ---------------Router
            /                   \ /                     \
    Network - Router ------------x                       Network
       A    \                   / \                     /   B
              Router -----------   ---------------Router

            | packets       |  packets  |  packets      |
 plaintext  | get           |  take a   |  get          | plaintext
 packets    | de/encrypted  |  random   |  de/encrypted | packets
            |de/encapsulated|   path    |de/encapsulated|              

            </artwork>
          </figure>
          <t>
            Network A has multiple routers which act as gateway/tunnel endpoints to another network B. This way a redundant encrypted tunnel connection between the two networks is built up. All tunnel endpoints of network A share the same anycast address and all tunnel endpoints of network B share another anycast address. When a packet from network A is transmitted to network B, it first arrives on one of network A's border routers. Which router is used is determined by network A's internal routing. This router encapsulates the package and sends it to the anycast address of network B's routers. After arrival the SATP packet gets decapsulated and routed to its destination within network B.
          </t>
        </section>
      </section>

      <section title="Encapsulation">
        <t>
          SATP does not depend on the lower layer protocol. This section only gives an example of how packets could look like.
        </t>
        <figure anchor="transport_udp">
          <preamble>Examples of SATP used with different lower layer and payload protocols</preamble>
          <artwork>
    +------+-----+-------------------------------+
    |      |     |      +----------------+-----+ |
    | IPv6 | UDP | SATP | Ethernet 802.3 | ... | |
    |      |     |      +----------------+-----+ |
    +------+-----+-------------------------------+

Tunneling of Ethernet over UDP/IPv6

    +------+-----+---------------------------+
    |      |     |      +------+-----+-----+ |
    | IPv4 | UDP | SATP | IPv6 | UDP | RTP | |
    |      |     |      +------+-----+-----+ |
    +------+-----+---------------------------+

Tunneling of IPv6 over UDP/IPv4 with RTP payload

    +------+-------------------------------+
    |      |      +----------------+-----+ |
    | IPv6 | SATP | Ethernet 802.3 | ... | |
    |      |      +----------------+-----+ |
    +------+-------------------------------+

Tunneling of Ethernet over IPv6

    +------+---------------------------+
    |      |      +------+-----+-----+ |
    | IPv4 | SATP | IPv6 | UDP | RTP | |
    |      |      +------+-----+-----+ |
    +------+---------------------------+

Tunneling of IPv6 over IPv4 with RTP payload
          </artwork>
        </figure>
      </section>
    </section>

    <section title="Using SATP on top of IP">
      <section title="Fragmentation">
        <t>
          The only way of fully supporting fragmentation would be to synchronise fragments between all anycast servers. This is considered to be too much overhead, so there are two non-perfect solutions for these problems. Either fragmentation HAS TO be disabled or if not all fragments arrive at the same server the IP datagramm HAS TO be discarded. As routing changes are not expected to occur very frequently, the encapsulated protocol can do a retransmission and all fragments will arrive at the new server. 
        </t>
        <t>
          If the payload type is IP and the IP headers' Don't Fragment (DF) bit is set, then the DF bit of the outer IP header HAS TO be set as well.
        </t>
      </section>
      <section title="ICMP messages">
        <t>
          ICMP messages MUST be relayed according to <xref target="RFC2003">rfc2003 section 4</xref>. This is needed for path MTU detection.
        </t>
      </section>
    </section>

    <section title="Protocol specification">
      <section title="Header format">
        <figure anchor="prot_header_table">
          <preamble>Protocol Format</preamble>
          <artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                         sequence number                       | |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
  |           sender ID           |              MUX              | |
+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+ |
| |         payload type          |                               | |
| +-------------------------------+                               | |
| |              ....        payload        ...                   | |
| |                               +-------------------------------+ |
| |                               | padding (OPT) | pad count(OPT)| |
+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+-+
| :                 authentication tag (RECOMMENDED)              : |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
|                                                                   |
+- Encrypted Portion                       Authenticated Portion ---+
          </artwork>
        </figure>
        <t></t>
      </section>
      <section title="sequence number">
        <t>
          The sequence number is a 32 bit unsigned integer in network byte order. The starting point is signaled by the key exchange mechanism and then value is then increased by 1 for every packet sent. After the maximum value it starts over from 0.
        </t>
      </section>
      <section title="sender ID">
        <t>
          The sender ID is a 16 bit unsigned integer. It HAS TO be unique for every sender sharing the same anycast address.
        </t>
      </section>
      <section title="MUX">
        <t>
          The MUX (multiplex) field is a 16 bit unsigned integer. It is used to distinguish multiple tunnel connections.
        </t>
      </section>
      <section title="payload type">
        <t>
          The payload type field defines the payload protocol. ETHER TYPE protocol numbers are used. <eref target="http://www.iana.org/assignments/ethernet-numbers">See IANA assigned ethernet numbers</eref> . The values 0000-05DC are reserverd and MUST NOT be used. 
          <figure anchor="prot_type_table">
            <preamble>Some examples for protocol numbers</preamble>
            <artwork>
HEX
0000 Reserved
.... Reserved
05DC Reserved
0800 Internet IP (IPv4)
6558 transparent ethernet bridging
86DD IPv6
            </artwork>
          </figure>
        </t>
      </section>
      <section title="payload">
        <t>
          A packet of type payload type (e.g. an IP packet).
        </t>
      </section>
      <section title="padding (OPTIONAL)">
        <t>
          Padding of max 255 octets. None of the pre-defined encryption transforms uses any padding; for these, the plaintext and encrypted payload sizes match exactly. Transforms which may be added in future (see <xref target="sec_adding_transform" />) MUST define wheter they need padding or not and if they need it they MUST define a proper padding format. If the padding count field is present, the padding count field MUST be set to the padding length.
        </t>
      </section>
      <section title="padding count (OPTIONAL)">
        <t>
          The number of octets of the padding field. This field is optional. Its presence is signaled by the key management and not by this protocol. If this field isn't present, the padding field MUST NOT be present as well.
        </t>
      </section>
      <section title="authentication tag (RECOMMENDED)">
        <t>
          The authentication tag is RECOMMENDED and of configurable length. It contains a cryptographic checksum of the sender ID, sequence number and the encrypted portion. On transmitter side encryption HAS TO be done before calculating the authentication tag. A receiver HAS TO calculate the authentication tag before decrypting the encrypted portion.
        </t>
      </section>
    </section>

    <section title="Cryptography">
      <t>
        As mentioned earlier the cryptography of SATP is based on <xref target="RFC3711">SRTP</xref>. For that reason we recommend to read this document as well (especially chapter 7 Rationale). However some modifications were made in order to fit the changed conditions of SATP. The following section describes the whole cryptography of SATP.
      </t>
      <section title="Basic Concepts">
        <t>
          In order to cope with anycast and packet loss it is important to be able to process one packet on its own without the need for packets from the past as an additional information source. Therefore SATP as well as <xref target="RFC3711">SRTP</xref> defines a so called cryptographic context. This context consits of all information which is needed to process a single SATP packet and is divided into packet specific parameters and global parameters. The packet specific parameters can be found in the protocol header and global parameters have to be generated by the key exchange mechanism external to SATP (see <xref target="sec_key_mgmt" />). For anycast sender the global parameters have to be synchronized between all hosts which share the same anycast address. The packet specific parameters MUST NOT be synchronized.<vspace blankLines="0" />
SATP uses two types of keys: master keys and session keys. A session key is meant to be used for a cryptographic transform (encrytion or message authentication) for one packet. The master keys are used to derive packet-specific session keys in a cryptographical secure way.
        </t>
        <section title="Cryptographic Contexts">
          <section title="Global Parameters">
            <t>
              As mentioned above global parameters HAVE TO either be provided by the key exchange mechanism or configured manually.
              <list style="symbols">
                <t>a master key(s) which MUST be random and kept secret.</t>
                <t>a master salt which MUST be random and MAY be public (RECOMMENDED to be kept secret as well).</t>
                <t>a role specifier used by the key derivation to determine which session keys to generate for outbound or inbound traffic.</t>
                <t>identifier for the key derivation pseudo random function.</t>
                <t>identifier for the encryption algorithm (i.e. cipher and its mode of operation).</t>
                <t>if used an identifier for the authentication algorithm.</t>
                <t>transform specific parameters such as key lengths, see <xref target="sec_pref_transform"/>.</t>
                <t>if used the length of the authentication tag which should be truncated to the packet.</t>
                <t>an indicator which specifies if padding is needed or not (presence of padding count field).</t>
                <t>a replay list for each sender (see <xref target="sec_mapping_context" />), maintained by the receiver which contains the sequence numbers of received and authenticated packets, this lists may be implemented as a sliding window.</t>
                <t>a [ From , To ] value pair which specifies the lifetime of a master key (including the range endpoints), expressed in terms of a pair of 32-bit sequence numbers.</t>
              </list>
            </t>
          </section>
          <section title="Packet-Specific Parameters">
            <t>
              <list style="symbols">
                <t>the sequence number</t>
                <t>the sender id</t>
                <t>the mux value</t>
              </list>
            </t>
          </section>
          <section title="Mapping SATP packets to Cryptographic Contexts" anchor="sec_mapping_context">
            <t>
              A cryptographic contexts SHALL be uniquely identifed by the tuple context identifier:
              <vspace blankLines="1" />
              context id = [ source address , source port ]
              <vspace blankLines="1" />
              In order to cope with anycast sender and replay protection there HAS TO be more than one replay list per context. Each replay list inside a cryptographic context SHALL be uniquely identified by the sender id.<vspace blankLines="0" />
              
            </t>
          </section>
        </section>
        <section title="SATP Packet Processing">
          <t>
            Before any SATP packet can be processed a cryptographic context HAS TO be initialized by the key management mechanism. After that a SATP sender SHALL do the following to create a SATP packet:
            <list style="numbers">
              <t>Determine the next sequence number to use.</t>
              <t>Determine the crypotgraphic context as described in <xref target="sec_mapping_context" />.</t>
              <t>Determine the master key and master salt for the packets sequence number.</t>
              <t>Compute all session keys and session salts which are needed by the encryption transform using the key derivation pseudo random function.</t>
              <t>Encrypt the payload type field concatenated with the payload to produce the encrypted portion of the packet using the encryption algorithm defined by the cryptographic context.</t>
              <t>Fill in sender id, mux and sequence number fields.</t>
              <t>If needed compute the session authentication key using the key derivation pseudo random function.</t>
              <t>Generate the authentication tag over the authenticated portion using the authentication algorithm defined by the cryptographic context and append it to the packet.</t>
            </list>
            On receiver side the packet SHALL be processed as follows:
            <list style="numbers">
              <t>Determine the crypotgraphic context as described in <xref target="sec_mapping_context" />.</t>
              <t>Determine the master key and master salt for the packets sequence number.</t>
              <t>Check if the packet was replayed using the replay list for the packets sender id.</t>
              <t>If needed compute the session authentication key using the key derivation pseudo random function.</t>
              <t>Generate the authentication tag over the authenticated portion using the authentication algorithm defined by the crpyptographic context and compare it with the tag appended to the received packet. If it is equal remove the tag and move on. If it is not equal drop the packet.</t>
              <t>Store the sequence number in the replay list.</t>
              <t>Compute all session keys and session salts which are needed by the encryption transform using the key derivation pseudo random function.</t>
              <t>Decrypt the encrypted portion using the encryption algorithm defined by the cryptographic context.</t>
              <t>Check if the payload type is supported by this tunnel endpoint and discard the packet in case it isn't supported.</t>
              <t>Remove all fields beside the payload itself from the packet.</t>
            </list>
          </t>
        </section>
        <section title="Key derivation" anchor="sec_key_derivation">
          <t>
            Any encryption or message authentication transform which is used (predefined or newly introduced according to <xref target="sec_adding_transform" />) MUST obtain its secret values (keys and salts) using the SATP key derivation. After the key exchange mechanism has signaled all needed parameters (i.e. master key and salt) no additional communiction between sender and receiver is needed until the next rekeying takes place. To achieve this the key derivation uses an pseudo random function seeded by the master key, master salt, the packets sequence number and a label (identifier for the key to compute).
          </t>
          <figure anchor="key_derivation">
            <preamble>SATP key derivation</preamble>            
            <artwork>
   packet sequence nummber ----+
                               |
                               V
  +------------+ master +------------+
  |            | key    |            |--> session encryption key
  | ext. key   |------->| key        |
  | management |        |            |--> session encryption salt
  | mechanism  |------->| derivation |
  |            | master |            |--> session authentication key
  +------------+ salt   +------------+
            </artwork>
          </figure>
          <t>
            <xref target="RFC3711">SRTP</xref> defines a pseudo random function as follows: <vspace blankLines="0" />
            Let m and n be positive integers. A pseudo-random function family is a set of keyed functions {PRF_n(k,x)} such that for the (secret) random key k, given m-bit x, PRF_n(k,x) is an n-bit string, computationally indistinguishable from random n-bit strings.<vspace blankLines="1" />
            For SATP key generation a pseudo random function with at least m = 128 MUST be used. A predefined transform can be found in <xref target="sec_pref_kdprf" />.
            The input x of the PRF SHOULD be calculated as follows:
            <list style="numbers">
              <t>Let key_id = label || sequence_number, with label defined as below.</t>
              <t>Let x = key_id XOR master_salt, where key_id and master_salt are aligend so that their least significant bits agree (right-alignment).</t>
            </list>
            For each key derived by the key derivation there MUST exist a unique label, a 32-bit constant. In order to increase security SATP uses different session keys for inbound and outbound traffic. The role specifier from the cryptographic context is used to determine which session keys to use for inbound and outbound packets.
            The labels can be computed by calculateing the SHA1 hash over an increasing label-index. The label value are the 32 leftmost bits of this hash value.
            We currently define 6 labels (label-index from 1 to 6) future extensions may use labels with an index from 7 upwards.
          </t>
          <texttable title="Key Derivation Labels">
            <ttcol align="left">key type</ttcol>
            <ttcol align="left">role</ttcol>
            <ttcol align="center">label-index</ttcol>
            <ttcol align="center">label</ttcol>
            <c>encryption key</c>
            <c>left</c>
            <c>1</c>
            <c>0x356A192B</c>
            <c>encryption key</c>
            <c>right</c>
            <c>2</c>
            <c>0xDA4B9237</c>
            <c>encryption salt</c>
            <c>left</c>
            <c>3</c>
            <c>0x77DE68DA</c>
            <c>encryption salt</c>
            <c>right</c>
            <c>4</c>
            <c>0x1B645389</c>
            <c>authentication key</c>
            <c>left</c>
            <c>5</c>
            <c>0xAC3478D6</c>
            <c>authentication key</c>
            <c>right</c>
            <c>6</c>
            <c>0xC1DFD96E</c>
          </texttable>
          <t>
            The role parameter specifies which label should be used for outbound packets. This means a endpoint with role left MUST use the labels marked with left for outgoing packets and expects inbound packets to be encrypted/authenticated using the labels marked with right.
          </t>
        </section>
      </section>
      <section title="Predefined Transforms" anchor="sec_pref_transform">
        <t>
          While SATP as well as SRTP allows the use of various encryption and message authentication algorithms interoperable implementations MUST support at least the following transforms. To add additional transforms see <xref target="sec_adding_transform" />.
        </t>
        <section title="Encryption">
          <section title="NULL Encryption">
            <t>
              If confidendtiality of the SATP packet is not an issue the null encryption transform can be used to increase performance. This transform just copies the plaintext input into the ciphertext output wihtout any padding. The identifier for that transfrom SHOULD be NULL and it don't needs any transform specific parameters. It also doesn't need any key or salt values computed by the key derivation.
            </t>
          </section>
          <section title="AES in Counter Mode">
            <t>
              The following describes how to use AES in counter mode for SATP encryption. The identifier for that transform SHOULD be AES-CTR-&lt;key_length&gt; or just AES-CTR in which case the key length defaults to 128 bits. Beside the key length there are no additional transfrom specific parameters. This transform needs a key of length &lt;key_length&gt; and a 112 bit salt. These values can be generated using the key derivation pseudo random function as follows:<vspace blankLines="1" />
              session_key = PRF_&lt;key_length&gt;(master_key, x)<vspace blankLines="0" />
              session_salt = PRF_112(master_key, x)<vspace blankLines="0" />
              with PRF and x defined as in <xref target="sec_key_derivation" />.<vspace blankLines="1" />
              Basically AES in counter mode generates a pseudo random keystream seeded by the session key, session salt as well as the sequence number, sender id and mux value of the packet and encrypts a single SATP packet using this stream. The encryption process consits of the generation of that keystream and then bitwise exclusive-oring it onto the packets payload. If the packet length doesn't fit a multiple of 128 bits the remaining bits (least significant) of the keystream are simple ingored. Therefore this transform does not need any padding. Decryption of the packet can be achieved by generating the same keystream and exclusive-oring it onto the encrypted portion. 
            </t>
            <section title="Keystram Generation">
              <t>
                In principle AES in counter mode consists of encrypting an incrementing integer. However the starting point of the integer value has to be randomized to get a good pseudo random key stream. A keystream consits of several keystream segements with a size of 128 bits (AES blocksize). Each segement can be computed by applying AES with key k on the block CTR. The whole keystream is a concatination of all its successive segements. Therefore a keystream looks as follows:<vspace blankLines="1" />
                AES(session_key, CTR) || AES(session_key, CTR + 1 mod 2^128) || AES(session_key, CTR + 2 mod 2^128) ...<vspace blankLines="1" />
                where the 128 bit value CTR is defined as follows:<vspace blankLines="1" />
                CTR = (session_salt * 2^16) XOR (mux * 2^80) XOR (sender_id * 2^64) XOR (sequence_number * 2^16)<vspace blankLines="1" />
                where each of the four terms are padded with as many leading zeros to form a 128 bit value.
              </t>
              <t>
                Mind that the 16 least siginificant bits of CTR are zero. These bits are used for the counter. Therefore the number of blocks generated for one packet MUST NOT exceed 2^16 to avoid keystream reuse. This means that the packet length MUST NOT exceed 2^16 * 128 bits = 2^23 bits to ensure the security of the encryption.
              </t>
            </section>
          </section>
        </section>
        <section title="Authentication and Integrity">
          <t>
            It is RECOMMENDED to use an authentication tag and if it is used it should be processed as follows. The sender generates the tag over the authenticated portion truncates it to the left-most (most significant) bits to fit the authentication tag length signaled by the key exchange mechanism. After that it simple appends the tag to the packet. The receiver computes the tag in the same way as the sender and compares if with the received tag. If they don't match the packet HAS TO be discarded and the incident SHOULD be logged.
          </t>
          <section title="HMAC-SHA1">
            <t>
              This transform uses HMAC-SHA1 (as described in <xref target="RFC2104" />) as message authentication algorithm. The identifier for the transfrom SHOULD be SHA1 and it don't needs any transform specific parameters. The key should be derived using the key derivation pseudo random function:<vspace blankLines="1" />
              session_auth_key = PRF_20(master_key, x)<vspace blankLines="0" />
              with PRF and x defined as in <xref target="sec_key_derivation" />
            </t>
          </section>
        </section>
        <section title="Key Derivation Pseudo Random Functions" anchor="sec_pref_kdprf">
          <section title="AES in Counter Mode">
            <t>
              <xref target="sec_key_derivation" /> defines a pseudo random function which SHOULD be used to derive session keys and salts. This describes the use of AES in counter mode as  PRF. The identifier for this PRF SHOULD be AES-CTR-&lt;key_length&gt; or just AES-CTR in which case the key length defaults to 128 bits. Beside the key length there are no additional transform specific parameters. This transform needs a master key of length key_length and a 112 bit master salt. The pseudo random string consists of several segements with a size of 128 bits (AES blocksize). The whole string can be computed as follows:<vspace blankLines="1" />
              AES(master_key, CTR) || AES(master_key, CTR + 1 mod 2^128) || AES(master_key, CTR + 2 mod 2^128) ...<vspace blankLines="1" />
              where the 128 bit value CTR is defined as x * 2^16, with x defined as in <xref target="sec_key_derivation" />.<vspace blankLines="1" />
              This pseudo random function can produce pseudo random strings up to a length of 2^23 bits. If the requested output length n does not fit multiples of 128 bits the output SHOULD be truncated to the n first (left-most) bits. Therefore there are n/128, rounded up, applications of AES needed to produce the output string.
            </t>
          </section>
        </section>
      </section>
      <section title="Adding SATP Transforms" anchor="sec_adding_transform">
        <t>
          If a new transform is to be added to SATP a standard track RFC MUST be written to define the usage of the new transform. Any overlap between the new RFC and this document SHOULD be avoided but it MAY be needed to update some of the information in this document. For example new parameters MAY be added to the cryptographic context or there MAY be additional steps in SATP packet processing.
        </t>
      </section>
    </section>
    
    <section title="Key Managment and Anycast Synchronization Considerations" anchor="sec_key_mgmt">
    </section>

    <section title="Security Considerations">
      <t>
        As the cryptography of SATP is based on <xref target="RFC3711">SRTP</xref>, it basically shares the same security issues. This section will only discuss some small changes. Please read <xref target="RFC3711">SRTP RFC3711 section 9</xref> for details.
      </t>
      <section title="Replay protection">
        <t>
          Replay protection is done by a replay list. Every anycast receiver has its own replay list, which SHOULDN'T be syncronised because of massive overhead. This leads to an additional possible attack. An attacker is able to replay a captured packet once to every anycast receiver. This attack is considered be very unlikely because multiple attack hosts in different locations are needed to reach seperate anycast receivers and the number of replays is limited to count of receivers - 1. Such replays might also happen because of routing problems, so a payload protocol HAS TO be robust against a small number of duplicated packages. The window size and position HAS TO be syncronised between multiple anycast receivers to limit this attack.
        </t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>
        The protocol is intended to be used on top of IP or on top of UDP (to be compatible with NAT routers), so UDP and IP protocol numbers have to be assiged by IANA.
      </t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      &rfc3711;
      &rfc2119;
      &rfc2003;
      &rfc2104;
    </references>
    <references title="Informational References">
      &rfc2784; 
      &rfc2401;
      &rfc1546;
    </references>
  </back>
</rfc>
