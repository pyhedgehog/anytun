<?xml version='1.0'?>
  <!DOCTYPE rfc SYSTEM 'rfcXXXX.dtd' [
       
  <!ENTITY rfc1546 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1546.xml'>
  <!ENTITY rfc3711 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml'>
  <!ENTITY rfc3068 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3068.xml'>
  <!ENTITY rfc2784 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2784.xml'>
  <!ENTITY rfc2401 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2401.xml'>
  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
  <!ENTITY rfc2003 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2003.xml'>
]>
<?rfc toc='yes'?>
<rfc ipr='full3978' docName='rfc-gsenger-pointner-secure-anycast-tunneling-protocol-01'>
  <front>
    <title>secure anycast tunneling protocol (SATP)</title>
    <author initials='O.G.' surname='Gsenger' fullname='Othmar Gsenger'>
      <organization></organization>
      <address>
        <postal>
          <street>Puerstingerstr 32</street>
          <city>Saalfelden</city>
          <code>5760</code>
          <country>AT</country>
        </postal>
        <phone></phone>
        <email>satp@gsenger.com</email>
        <uri>http://www.gsenger.com/satp/</uri>
      </address>
    </author>
    <author initials='C.P.' surname='Pointner' fullname='Christian Pointner'>
      <organization></organization>
      <address>
        <postal>
          <street>Wielandgasse 19</street>
          <city>Graz</city>
          <code>8010</code>
          <country>AT</country>
        </postal>
        <phone></phone>
        <email>equinox@anytun.org</email>
      </address>
    </author>

    <date month='April' year='2009' />

    <area>General</area>
    <workgroup></workgroup>
    <keyword>satp</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>secure anycast tunneling protocol</keyword>
    <keyword>anycast</keyword>
    <keyword>tunnel</keyword>
    <keyword>secure</keyword>
    <keyword>protocol</keyword>

    <abstract>
      <t>
        The secure anycast tunneling protocol (SATP) defines a protocol used for communication between any combination of unicast and anycast tunnel endpoints. It allows tunneling of every ETHER TYPE protocol (ethernet, ip ...). SATP directly includes cryptography and message authentication based on the methods used by the <xref target="RFC3711">Secure Real-time Transport Protocol(SRTP)</xref>. It can be used as an encrypted alternative to <xref target="RFC2003">IP Encapsulation within IP</xref> and <xref target="RFC2784">Generic Routing Encapsulation (GRE)</xref>. Both anycast receivers and senders are supported.
      </t>
    </abstract>
  </front>

  <middle>
    <section title='Introduction'>
      <t>
        SATP is a mixture of a generic encapsulation protocol like <xref target="RFC2784">GRE</xref> and a secure tunneling protocol as <xref target="RFC2401">IPsec</xref> in tunnel mode.  It can be used to build redundant virtual private network (VPN) connections.  It supports peer-to-peer tunnels, where tunnel endpoints can be any combination of unicast, multicast or anycast hosts, so it defines a <xref target="RFC1546">Host Anycast Service</xref>. Encryption is done per packet, so the protocol is robust against packet loss and routing changes.
To reduce header overhead, encryption techniques of <xref target="RFC3711">SRTP</xref> are being used.
      </t>
      <section title='Notational Conventions'>
        <t>
          The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in  <xref target="RFC2119">RFC2119</xref>.
        </t>
      </section>
    </section> 
    
    <section title="Motivation and usage scenarios">
      <t>
        This section gives an overview of possible usage scenarios. Please note that the protocols used in the figures are only examples and that SATP itself does not care about either transport protocols or encapsulated protocols. Routing is not done by SATP and each implemetation MAY choose it's own way of doing this task (e.g. using functions provided by the operating system). SATP is used only to encapsulate and encrypt data.
      </t>
      <section title="Usage scenarions">
        <section title='Tunneling from unicast hosts over anycast routers to other unicast hosts'>
          <figure anchor="tunnel_mode">
            <preamble>An example of SATP used to tunnel in a unicast client - anycast server model</preamble>
            <artwork>
                    --------- router ----------- 
                   /                            \ 
    unicast ------+---------- router ------------+------ unicast
    host           \                            /        host
                    --------- router -----------  

  unicast  | encrypted     |  anycast  | encrypted     |  unicast
  tunnel   | communication |  tunnel   | communication |  tunnel  
  endpoint | using SATP    |  endpoint | using SATP    |  endpoint 
            </artwork>
          </figure>
          <t>
            In this scenario the payload is encapsuleted into a SATP packet by a unicast host and gets transmitted to one of the anycast routers. After transmisson the packet gets decapsulated by the router. This router makes a routing descision based on the underlying protocol and transmits a new SATP package to one or more unicast hosts depending on this decision.
          </t> 
        </section>
        <section title='Tunneling from unicast hosts to anycast networks'>
          <figure anchor="open_tunnel_mode">
            <preamble>An example of SATP used to encrypt data between a unicast host and anycast networks</preamble>
            <artwork>
                       -------Router -+---- DNS Server
                      /                \ 
                     /                  --- 6to4 Router
                    /
    unicast -------+----------Router --+--- DNS Server
    host            \                   \  
                     \                   --- 6to4 Router
                      \
                       -------Router -+---- DNS Server
                                       \
                                        --- 6to4 Router

  unicast  | encrypted     |  anycast  | plaintext
  tunnel   | communication |  tunnel   | anycast
  endpoint | using SATP    |  endpoint | services

            </artwork>
          </figure>
          <t>
            When the unicast hosts wants to transmit data to one of the anycast DNS servers, it encapsulates the data and sends a SATP packet to the anycast address of the routers. The packet arrives at one of the routers, gets decapsulated and is then forwarded to the DNS server. This method can be used to tunnel between clients and networks providing anycast services. It can also be used the other way to virtually locate a unicast service within anycasted networks.
          </t>
        </section>
        <section title='Redundant tunnel connection of 2 networks'>
          <figure anchor="connect_networks">
            <preamble>An example of SATP used to connect 2 networks</preamble>
            <artwork>
              Router -----------   ---------------Router
            /                   \ /                     \
    Network - Router ------------x                       Network
       A    \                   / \                     /   B
              Router -----------   ---------------Router

            | packets       |  packets  |  packets      |
 plaintext  | get           |  take a   |  get          | plaintext
 packets    | de/encrypted  |  random   |  de/encrypted | packets
            |de/encapsulated|   path    |de/encapsulated|              

            </artwork>
          </figure>
          <t>
            Network A has multiple routers which act as gateway/tunnel endpoints to another network B. This way a redundant encrypted tunnel connection between the two networks is built up. All tunnel endpoints of network A share the same anycast address and all tunnel endpoints of network B share another anycast address. When a packet from network A is transmitted to network B, it first arrives on one of network A's border routers. Which router is used is determined by network A's internal routing. This router encapsulates the package and sends it to the anycast address of network B's routers. After arrival the SATP packet gets decapsulated and routed to its destination within network B.
          </t>
        </section>
      </section>

      <section title="Encapsulation">
        <t>
          SATP does not depend on the lower layer protocol. This section only gives an example of how packets could look like.
        </t>
        <figure anchor="transport_udp">
          <preamble>Examples of SATP used with different lower layer and payload protocols</preamble>
          <artwork>
    +------+-----+-------------------------------+
    |      |     |      +----------------+-----+ |
    | IPv6 | UDP | SATP | Ethernet 802.3 | ... | |
    |      |     |      +----------------+-----+ |
    +------+-----+-------------------------------+

Tunneling of Ethernet over UDP/IPv6

    +------+-----+---------------------------+
    |      |     |      +------+-----+-----+ |
    | IPv4 | UDP | SATP | IPv6 | UDP | RTP | |
    |      |     |      +------+-----+-----+ |
    +------+-----+---------------------------+

Tunneling of IPv6 over UDP/IPv4 with RTP payload

    +------+-------------------------------+
    |      |      +----------------+-----+ |
    | IPv6 | SATP | Ethernet 802.3 | ... | |
    |      |      +----------------+-----+ |
    +------+-------------------------------+

Tunneling of Ethernet over IPv6

    +------+---------------------------+
    |      |      +------+-----+-----+ |
    | IPv4 | SATP | IPv6 | UDP | RTP | |
    |      |      +------+-----+-----+ |
    +------+---------------------------+

Tunneling of IPv6 over IPv4 with RTP payload
          </artwork>
        </figure>
      </section>
    </section>

    <section title="Using SATP on top of IP">
      <section title="Fragmentation">
        <t>
          The only way of fully supporting fragmentation would be to synchronise fragments between all anycast servers. This is considered to be too much overhead, so there are two non-perfect solutions for these problems. Either fragmentation HAS TO be disabled or if not all fragments arrive at the same server the IP datagramm HAS TO be discarded. As routing changes are not expected to occur very frequently, the encapsulated protocol can do a retransmission and all fragments will arrive at the new server. 
        </t>
        <t>
          If the payload type is IP and the IP headers' Don't Fragment (DF) bit is set, then the DF bit of the outer IP header HAS TO be set as well.
        </t>
      </section>
      <section title="ICMP messages">
        <t>
          ICMP messages MUST be relayed according to <xref target="RFC2003">rfc2003 section 4</xref>. This is needed for path MTU detection.
        </t>
      </section>
    </section>

    <section title="Protocol specification">
      <section title="Header format">
        <figure anchor="prot_header_table">
          <preamble>Protocol Format</preamble>
          <artwork>
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         sequence number                       | |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
     |           sender ID           |              MUX              | |
   +#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+ |
   | |         payload type          |                               | |
   | +-------------------------------+                               | |
   | |              ....        payload        ...                   | |
   | |                               +-------------------------------+ |
   | |                               | padding (OPT) | pad count(OPT)| |
   +#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+-+
   | :                 authentication tag (RECOMMENDED)              : |
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   |                                                                   |
   +- Encrypted Portion                       Authenticated Portion ---+
          </artwork>
        </figure>
        <t></t>
      </section>
      <section title="sequence number">
        <t>
          The sequence number is a 32 bit unsigned integer in network byte order. It starts with a random value and is increased by 1 for every sent packet. After the maximum value it starts over from 0. This overrun causes the ROC to be increased.
        </t>
      </section>
      <section title="sender ID">
        <t>
          The sender ID is a 16 bit unsigned integer. It HAS TO be unique for every sender sharing the same anycast address.
        </t>
      </section>
      <section title="MUX">
        <t>
          The MUX (multiplex) field is a 16 bit unsigned integer. It is used to distinguish multiple tunnel connections.
        </t>
      </section>
      <section title="payload type">
        <t>
          The payload type field defines the payload protocol. ETHER TYPE protocol numbers are used. <eref target="http://www.iana.org/assignments/ethernet-numbers">See IANA assigned ethernet numbers</eref> . The values 0000-05DC are reserverd and MUST NOT be used. 
          <figure anchor="prot_type_table">
            <preamble>Some examples for protocol numbers</preamble>
            <artwork>
HEX
0000 Reserved
.... Reserved
05DC Reserved
0800 Internet IP (IPv4)
6558 transparent ethernet bridging
86DD IPv6
            </artwork>
          </figure>
        </t>
      </section>
      <section title="payload">
        <t>
          A packet of type payload type (e.g. an IP packet).
        </t>
      </section>
      <section title="padding (OPTIONAL)">
        <t>
          Padding of max 255 octets. None of the pre-defined encryption transforms uses any padding; for these, the plaintext and encrypted payload sizes match exactly. Transforms are based on transforms of the SRTP protocol and therefore might use the RTP padding format, so a RTP-like padding is supported. If the padding count field is present, the padding count field MUST be set to the padding length.
        </t>
      </section>
      <section title="padding count (OPTIONAL)">
        <t>
          The number of octets of the padding field. This field is optional. Its presence is signaled by the key management and not by this protocol. If this field isn't present, the padding field MUST NOT be present as well.
        </t>
      </section>
      <section title="authentication tag (RECOMMENDED)">
        <t>
          The authentication tag is RECOMMENDED and of configurable length. It contains a cryptographic checksum of the sender ID, sequence number and the encrypted portion. On transmitter side encryption HAS TO be done before calculating the authentication tag. A receiver HAS TO calculate the authentication tag before decrypting the encrypted portion.
        </t>
      </section>
    </section>

    <section title="Cryptography">
      <t>
        As mentioned earlier the cryptography of SATP is based on <xref target="RFC3711">SRTP</xref>. For that reason we recommend to read this document as well. However some modifications were made in order to fit the changed conditions of SATP. The following section describes the whole cryptography of SATP.
      </t>
      <section title="Basic Concepts">
        <t>
          In order to cope with anycast and packet loss it is important to being able to process one packet on its own without the need for packets from the past as an additional information source. Therefore SATP as well as <xref target="RFC3711">SRTP</xref> defines a so called cryptographic context. This context consits of all information which is needed to process a single SATP packet and is divided into packet specific parameters and global parameters. The packet specific parameters can be found in the protocol header and global parameters have to be generated by the key exchange mechanism external to SATP (see <xref target="sec_key_mgmt" />. For anycast sender the global parameters have to be synchronized between all host which share the same anycast address. The packet specific parameters MUST NOT be synchronized.<vspace blankLines="0" />
SATP uses two types of keys: master keys and session keys. A session key is meant to be used for a cryptographic transform (encrytion or message authentication) for one packet. The master keys are used to derive packet-specific session keys in a cryptographical secure way.
        </t>
        <section title="Cryptographic Contexts">
          <section title="Global Parameters">
            <t>
              As mentioned above global parameters HAVE TO either be provided by the key exchange mechanism or configured manually.
              <list style="symbols">
                <t>master key(s) which MUST be random and kept secret</t>
                <t>if needed master salt(s) which MUST be random an MAY be public (RECOMMENDED to be secret as well)</t>
                <t>identifier for the encryption algorithm (i.e. cipher and its mode of operation)</t>
                <t>identifier for the authentication algorithm</t>
                <t>transform specific parameters such as key lengths, see <xref target="sec_pref_transform"/></t>
                <t>a replay list for each sender (see <xref target="sec_mapping_context" />), maintained by the receiver which contains the sequence numbers of received and authenticated packets, this list may be implemented as a sliding window</t>
                <t>a [ From , To ] value pair which specifies the lifetime of a master key (including the range endpoints), expressed in terms of a pair of 32-bit sequence numbers.</t>
              </list>
            </t>
          </section>
          <section title="Packet-Specific Parameters">
            <t>
              <list style="symbols">
                <t>the sequence number</t>
                <t>the sender id</t>
                <t>the mux value</t>
              </list>
            </t>
          </section>
          <section title="Mapping SATP packets to Cryptographic Contexts" anchor="sec_mapping_context">
            <t>
              A cryptographic contexts SHALL be uniquely identifed by the tuple context identifier:
              <vspace blankLines="1" />
              context id = [ source address , source port ]
              <vspace blankLines="1" />
              In order to cope with anycast sender and replay protection there HAS TO be more than one replay list per context. Each replay list inside a cryptographic context SHALL be uniquely identified by the sender id.
            </t>
          </section>
        </section>
        <section title="SATP Packet Processing  ">
          <t></t>
        </section>
        <section title="Key derivation">
          <t>
            All transforms (predfined or not) .. the SATP key derivation HAS TO be used .. uses pseudo random function .. master key and salt as seed
          </t>
          <figure anchor="key_derivation">
            <preamble>SATP key derivation</preamble>            
            <artwork>
    packet sequence nummber ----------+
                                      |
    packet mux value -------------+   |
                                  |   |
    packet sender id ---------+   |   |
                              |   |   |
                              V   V   V
 +------------+             +------------+
 |            | master key  |            |--> session encryption key
 | ext. key   |------------>| key        |
 | management |             |            |--> session encryption salt
 | mechanism  |------------>| derivation |
 |            | master salt |            |--> session authentication key
 +------------+             +------------+
            </artwork>
          </figure>
        </section>
      </section>
      <section title="Predefined Transforms" anchor="sec_pref_transform">
        <section title="Encryption">
        </section>
        <section title="Authentication and Integrity">
        </section>
        <section title="Key Derivation Pseudo Random Functions">
        </section>
      </section>
      <section title="Default and Mandatory-to-implement Transforms">
        <section title="Encryption">
        </section>
        <section title="Authentication and Integrity">
        </section>
        <section title="Key Derivation Pseudo Random Functions">
        </section>
      </section>
      <section title="Adding SATP Transforms">
      </section>
    </section>
    
    <section title="Key Managment and Anycast Synchronization Considerations" anchor="sec_key_mgmt">
    </section>

    <section title="Security Considerations">
      <t>
        As SATP uses the same encryption techniques as <xref target="RFC3711">SRTP</xref>, it shares the same security issues. This section will only discuss some small changes. Please read <xref target="RFC3711">SRTP RFC3711 section 9</xref> for details.
      </t>
      <section title="Replay protection">
        <t>
          Replay protection is done by a replay list. Every anycast receiver has its own replay list, which SHOULDN'T be syncronised because of massive overhead. This leads to an additional possible attack. An attacker is able to replay a captured packet once to every anycast receiver. This attack is considered be very unlikely because multiple attack hosts in different locations are needed to reach seperate anycast receivers and the number of replays is limited to count of receivers - 1. Such replays might also happen because of routing problems, so a payload protocol HAS TO be robust against a small number of duplicated packages. The window size and position HAS TO be syncronised between multiple anycast receivers to limit this attack.
        </t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>
        The protocol is intended to be used on top of IP or on top of UDP (to be compatible with NAT routers), so UDP and IP protocol numbers have to be assiged by IANA.
      </t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      &rfc3711;
      &rfc2119;
      &rfc2003;
    </references>
    <references title="Informational References">
      &rfc2784; 
      &rfc2401;
      &rfc1546;
    </references>
  </back>
</rfc>
