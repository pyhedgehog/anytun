<?xml version='1.0'?>
    <!DOCTYPE rfc SYSTEM 'rfcXXXX.dtd' [
    
    <!ENTITY rfc3068 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3068.xml'>
    <!ENTITY rfc3711 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml'>

]>
    <rfc ipr='full3978' docName='draft-gsenger-secure-anycast-tunneling-protocol-00'>
    <front>
        <title>secure anycast tunneling protocol (satp)</title>

        <author initials='O.G.' surname='Gsenger'
                fullname='Othmar Gsenger'>
            <organization></organization>

            <address>
                <postal>
                    <street>Sporgasse 6</street>
                    <city>Graz</city>
                    <code>8010</code>
                    <country>AT</country>
                </postal>

                <phone></phone>
                <email>otti@wirdorange.org</email>
                <uri>http://anytun.org/</uri>
            </address>
        </author>

        <date month='March' year='2007' />

        <area>General</area>
        <workgroup></workgroup>
        <keyword>satp</keyword>
        <keyword>Internet-Draft</keyword>
        <keyword>secure anycast tunneling protocol</keyword>
        <keyword>anycast</keyword>
        <keyword>tunnel</keyword>
        <keyword>secure</keyword>
        <keyword>protocol</keyword>
        <abstract>
            <t>The secure anycast tunneling protocol (satp) defines a protocol used for communication between any combination of unicast and anycast tunnel endpoints. It has less protocol overhead than IPSec in Tunnel mode and allows tunneling of every ETHER TYPE protocol (e.g. ethernet, ip, arp ...). satp directly includes cryptography and message authentication based on the methodes used by SRTP. It is intended to deliver a generic, scaleable, secure and reliability solution for tunneling and relaying of packets of any protocol.
            </t>
        </abstract>
    </front>
    <middle>
    <section title='Introduction'>
        <t>anytun defines a Host Anycast Service as defined in rfc1546. It uses a peer-to-peer achitecture, with anycast servers and unicast clients. It can be used to build high scalable and redundant tunnel services. It also has a relay mode, that makes it possible, that only one of the connection endpoints has to use the anytun protocol. This can be used to make connections through Firewalls or behind a NAT Router</t>
         <t><xref target="RFC3068">RFC3068</xref> DTD.</t>
    </section> 
    <section title="Operation modes">
       <t>This section gives an overview of possible operation modes und usage scenarios. Please note, that the protocols used in the figures are only examples and that anytun itself does not care about either transport protocols or encapsulated protocols. Routing and network address translation is not done by anytun. Each implemetation MAY choose it's own way of doing this task (e.g. using functions provided by the operating system). Anytun is used to establish and controll tunnnels, to encapsulate and encrypt data.</t>
       <section title="Usage scenarions">
    
            <section title='tunneling from unicast client over anycast servers to unicast client'>
              <figure anchor="tunnel_mode">
                 <preamble>An example of anytun used in tunnel mode</preamble>
                 <artwork>
          -----------                      ----------- 
          |   RTP   |      ----------      |   RTP   |
          -----------  ->  |server 1|  ->  -----------
          |   UDP   |      ----------      |   UDP   |
          -----------                      -----------
-----     |   IPv6  |      ----------      |   IPv6  |     -----
|   |  -> -----------  ->  |server 2|  ->  -----------  -> |   |
-----     |  anytun |      ----------      |  anytun |     -----
#####     -----------                      -----------     #####
          |   UDP   |      ----------      |   UDP   |
client 1  -----------  ->  |server 3|  ->  -----------     client 2
          |   IPv4  |      ----------      |   IPv4  |
          -----------                      -----------
          |   ...   |       anycast        |   ...   |
                 </artwork>
       </figure>
	      <t>In tunneling mode the payload of the anytun packet is transmitted from one unicast host to the anycast server. This server makes a routing descision based on the underlying protocol and transmits a new anytun package to one or more clients depending on the routing descition. The server MAY also route the packet to a directly connected network or a service running on the server, but please note, that this is only usefull for anycast host services like DNS and that the services HAVE TO be running on all servers in order to work.</t> 
	    </section>

	    <section title='tunneling from client to a server connected network'>
              <figure anchor="open_tunnel_mode">
                 <preamble>An example of anytun used in open tunnel mode</preamble>
                 <artwork>
          -----------                                 
          |   RTP   |      ----------                 
          -----------  ->  |server 1|  ->             
          |   UDP   |      ----------      -----------
          -----------                      |   RTP   |
-----     |   IPv6  |      ----------      -----------     -----
|   |  -> -----------  ->  |server 2|  ->  |   UDP*  |  -> |   |
-----     |  anytun |      ----------      -----------     -----
#####     -----------                      |   IPv6* |     #####
          |   UDP   |      ----------      -----------
client 1  -----------  ->  |server 3|  ->  |   ...   |    host
          |   IPv4  |      ----------                     not using
          -----------                                     anytun
          |   ...   |       anycast        
                                           *changed source address
                                            or port   
                 </artwork>
       </figure>

               <t>In open tunnel mode only one of two clients talking to each other over the servers MUST use the anytun protocol. When a client using the anytun protocol wants to tunnel data, it is building a connection to the anycast servers using the anytun protocol. The anycast servers relay the encapsulated packages directly to the destination without using the anytun protocol. The source address of the datagramm HAS TO be changed to the anycast address of the server. The anytun servers act like a source NAT router, therefor for the destination it saems that it is talking to the client directly.</t>
	    </section>
	</section>
	<section title="Transport modes">
      <t>Anytun does not define wich lower layer protocols HAVE TO be used, but it's most likely used on top of udp. This section should only discuss some issues on udp in combination with anycasting and tunnels.
      </t>
	  <section title="Using UDP">
              <figure anchor="transtort_udp">
                 <preamble>An example of anytun used with udp as transport</preamble>
                 <artwork>
          -----------                      -----------
          |   RTP   |      ----------      |   RTP   |
          -----------  ->  |server 1|  ->  -----------
          |   UDP   |      ----------      |   UDP   |
          -----------                      -----------
-----     |   IPv6  |      ----------      |   IPv6  |     -----
|   |  -> -----------  ->  |server 2|  ->  -----------  -> |   |
-----     |  anytun |      ----------      |  anytun |     -----
#####     -----------                      -----------     #####
          |   UDP   |      ----------      |   UDP   |
client 1  -----------  ->  |server 3|  ->  -----------     client 2
          |   IPv4  |      ----------      |   IPv4  |
          -----------                      -----------
          |   ...   |       anycast        |   ...   |
                 </artwork>
       </figure>
      <t>When using UDP no flow controll or retransmission is done, neigther by UDP nor anytun. The encapsulated protocol HAS TO take care of this tasks if needed. UDP however has a checksum of the complete udp datagram, so a packet gets discarded if there is a biterror in the payload</t>
	  </section>
	  <section title="Using lightUDP">
              <figure anchor="transport_lightudp">
                 <preamble>An example of anytun used with udp transport</preamble>
                 <artwork>
          -----------                      -----------
          |   RTP   |      ----------      |   RTP   |
          -----------  ->  |server 1|  ->  -----------
          |   UDP   |      ----------      |   UDP   |
          -----------                      -----------
-----     |   IPv6  |      ----------      |   IPv6  |     -----
|   |  -> -----------  ->  |server 2|  ->  -----------  -> |   |
-----     |  anytun |      ----------      |  anytun |     -----
#####     -----------                      -----------     #####
          |lightUDP |      ----------      |lightUDP |
client 1  -----------  ->  |server 3|  ->  -----------     client 2
          |   IPv4  |      ----------      |   IPv4  |
          -----------                      -----------
          |   ...   |       anycast        |   ...   |
                 </artwork>
       </figure>

      <t>The difference between normal UDP and lightUDP is, that the udp size is not set to the length of the full packet, but to the lenght of the data used for the checksum and therefor the checksum is only calculated for that part. When using lightUDP, the lenght HAS tO be set to the udp header length + the anytun header lenght. So there is no error correction or detection done on the payload. This can be usefull if realtime data is beeing transimittet or the tunneled protocol does error correction/detection by itself.</t>
    </section>
         <section title="Fragmentation">
         <t>
           The only way of fully supporting fragmentation would be to syncronise fragments between all anycast servers. This is considered to be to much overhead, so there are two non perfect solutions for this problems. Either fragmentation HAS TO be disabled or if not all fragments arrive at the same server the ip datagramm HAS TO be discarded. As routing changes are not expected to occure very frequently, the encapsulated protocol can do a retransmission and all fragments will arrive at the new server.
         </t>
         </section>
   </section>
     <section title="Protocol specification">
       <section title="Header format">
            <figure anchor="prot_header_table">
               <preamble>Protocol Format</preamble>
                 <artwork>
        0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         sequence number                       | |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   | |              ....        payload        ...                   | |
   | |-------------------------------+-------------------------------+ |
   | | padding (OPT) | pad count(OPT)|         payload type          | |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | ~                          MKI (OPTIONAL)                       ~ |
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   | :                 authentication tag (RECOMMENDED)              : |
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   |                                                                   |
   +- Encrypted Portion*                      Authenticated Portion ---+
</artwork>
</figure>
<t></t>
       </section>
       <section title="sequence number">
       <t>The sequenze number is a 32bit unsigned integer in network byte order. It starts with a random value and is increased by 1 for every sent packet. After the maximum value, it starts over from 0. This overrun causes the ROC to be increased.</t>
       </section>
       <section title="payload">
       <t>A packet of the type payload type (e.g. an IP packet).</t>
       </section>
       <section title="padding (OPTINAL)">
       <t>Padding of max 255 ocitets.
None of the pre-defined encryption transforms uses any padding; for
   these, the plaintext and encrypted payload sizes match exactly. Transforms are based on transforms of the SRTP protocol and these transforms might use the RTP padding format, so a RTP like padding is supported. If padding field is present, than the padding count field MUST be set to the padding lenght.</t>
       </section>
       <section title="padding count">
       <t>The number of octets of the padding field. This field is optional. It's presents is signaled by the key management and not by this protocol. If this field isn't present, the padding field MUST NOT be present as well.</t>
       </section>
       <section title="payload type field">
         <t>The payload type field defines the payload protocol. ETHER TYPE protocol numerbers are used. http://www.iana.org/assignments/ethernet-numbers . The values 0000-05DC are reserverd and MUST NOT be used. 
            <figure anchor="prot_type_table">
               <preamble>Some examples for protocol types</preamble>
                 <artwork>
HEX
0000 Reserved
.... Reserved
05DC Reserved
0800 Internet IP (IPv4)
6558 transparent ethernet bridging
86DD IPv6
</artwork>
</figure>
</t>
     </section>
    </section>
    </section>
        <appendix title='The appan'></appendix>
    </middle>
    <back>
    <references>
        &rfc3068; An Anycast Prefix for 6to4 Relay Routers
    </references>
    </back>
    </rfc>
