#
# ----------- global configuration parameters ------------------------

fork=yes
#listen=83.64.208.28
port=5060
log_stderror=no
debug=3

check_via=no    # (cmd. line: -v)
dns=no          # (cmd. line: -r)
rev_dns=no      # (cmd. line: -R)
children=4
fifo="/tmp/openser_fifo"

# ------------------ module loading ----------------------------------

loadmodule "/usr/lib/openser/modules/sl.so"
loadmodule "/usr/lib/openser/modules/tm.so"
loadmodule "/usr/lib/openser/modules/rr.so"
loadmodule "/usr/lib/openser/modules/textops.so"
loadmodule "/usr/lib/openser/modules/maxfwd.so"
loadmodule "/usr/lib/openser/modules/usrloc.so"
loadmodule "/usr/lib/openser/modules/registrar.so"

loadmodule "/usr/lib/openser/modules/nathelper.so"

loadmodule "/usr/lib/openser/modules/xlog.so"


## ----------------- setting module-specific parameters ---------------

modparam("usrloc", "db_mode",   0)

modparam("rr", "enable_full_lr", 1)

modparam("nathelper", "rtpproxy_sock", "udp:localhost:22222")

# -------------------------  request routing logic -------------------

route{
        xlog("L_ERR", "@route: method <$rm> r-uri <$ru>\n");

	# initial sanity checks -- messages with
	# max_forwards==0, or excessively long requests
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	};

	if (msg:len >=  2048 ) {
		sl_send_reply("513", "Message too big");
		exit;
	};

	# we record-route all messages -- to make sure that
	# subsequent messages will go through our proxy; that's
	# particularly good if upstream and downstream entities
	# use different transport protocol
	if (method!="REGISTER") 
		record_route();


	if (method=="BYE" || method=="CANCEL") {
		unforce_rtp_proxy();
	};

	# subsequent messages withing a dialog should take the
	# path determined by record-routing
	if (loose_route()) {
		if (method=="INVITE") {
			route(3);
		};
		route(1);
	};

	if (!uri==myself) {
		if (method=="INVITE") {
			route(3);
		};
		route(1);
	};

	if (method=="ACK") {
	 	route(1);
	} else if (method=="REGISTER") {
		route(2);
	};
	
	lookup("aliases");
	if (uri!=myself) {
		if (method=="INVITE") {
			route(3);
		};
		route(1);
	};
	
	# native SIP destinations are handled using our USRLOC DB
	if (!lookup("location")) {
		sl_send_reply("404", "Not Found");
		exit;
	};

	if (method=="INVITE") {
		route(3);
	};

	route(1);
}


route[1] {
	# send it out now; use stateful forwarding as it works reliably
	# even for UDP2TCP
	if (!t_relay()) {
		sl_reply_error();
	};
	exit;
}

route[2] {
	if (!save("location")) {
		sl_reply_error();
	};
	exit;
}

route[3] {
	force_rtp_proxy("","83.64.208.28");
}

onreply_route {
	if (!search("^Content-Length:[ ]*0")) {
		route(3);
        };
}
