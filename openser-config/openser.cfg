# ----------- global configuration parameters ------------------------

fork=yes
port=5060
log_stderror=no
debug=3
alias=voip.anytun.org:5060

check_via=no    # (cmd. line: -v)
dns=yes          # (cmd. line: -r)
rev_dns=yes      # (cmd. line: -R)
children=4
fifo="/tmp/openser_fifo"
fifo_db_url="mysql://anytunro:woasinidro@localhost/anytun"

# ------------------ module loading ----------------------------------

loadmodule "/usr/lib/openser/modules/mysql.so"
loadmodule "/usr/lib/openser/modules/sl.so"
loadmodule "/usr/lib/openser/modules/tm.so"
loadmodule "/usr/lib/openser/modules/rr.so"
loadmodule "/usr/lib/openser/modules/textops.so"
loadmodule "/usr/lib/openser/modules/maxfwd.so"
loadmodule "/usr/lib/openser/modules/usrloc.so"
loadmodule "/usr/lib/openser/modules/registrar.so"
loadmodule "/usr/lib/openser/modules/auth.so"
loadmodule "/usr/lib/openser/modules/auth_db.so"
loadmodule "/usr/lib/openser/modules/uri_db.so"
loadmodule "/usr/lib/openser/modules/nathelper.so"


## ----------------- setting module-specific parameters ---------------

modparam("auth_db|uri_db", "db_url", "mysql://anytunro:woasinidro@localhost/anytun")
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")

modparam("usrloc", "db_url", "mysql://anytun:woasinid@localhost/anytun")
modparam("usrloc", "db_mode",   2)

modparam("rr", "enable_full_lr", 1)

modparam("nathelper", "rtpproxy_sock", "udp:193.238.157.58:22222")

# -------------------------  request routing logic -------------------

route{
	# initial sanity checks -- messages with
	# max_forwards==0, or excessively long requests
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	};

	if (msg:len >=  2048 ) {
		sl_send_reply("513", "Message too big");
		exit;
	};

	# we record-route all messages -- to make sure that
	# subsequent messages will go through our proxy; that's
	# particularly good if upstream and downstream entities
	# use different transport protocol
	if (method!="REGISTER") 
		record_route();


	if (method=="BYE" || method=="CANCEL") {
		unforce_rtp_proxy();
	};

	# subsequent messages withing a dialog should take the
	# path determined by record-routing
	if (loose_route()) {
		route(4);
		route(1);
	};

	if (!uri==myself) {
		route(4);
		route(1);
	};

	if (method=="ACK") {
	 	route(1);
	} if (method=="INVITE") {
   		route(3);
	} else if (method=="REGISTER") {
		route(2);
	};
	
	lookup("aliases");
	if (uri!=myself) {
		route(4);
		route(1);
	};
	
	# native SIP destinations are handled using our USRLOC DB
	if (!lookup("location")) {
		sl_send_reply("404", "Not Found");
		exit;
	};

	route(4);
	route(1);
}


route[1] {
	# send it out now; use stateful forwarding as it works reliably
	# even for UDP2TCP
	if (!t_relay()) {
		sl_reply_error();
	};
	exit;
}

route[2] {
	sl_send_reply("100", "Trying");
  
	if (!www_authorize("","subscriber")) {
		www_challenge("","0");
		exit;
	};

	if (!check_to()) {
		sl_send_reply("401", "Unauthorized");
		exit;
	};

	consume_credentials();

	if (!save("location")) {
		sl_reply_error();
	};
	exit;
}

route[3] {
	if (!proxy_authorize("","subscriber")) {
		proxy_challenge("","0");
		exit;
	} else if (!check_from()) {
		sl_send_reply("403", "Use From=ID");
		exit;
	};

	consume_credentials();

	lookup("aliases");
	if (uri!=myself) {
		route(4);
		route(1);
	};

	if (!lookup("location")) {
		sl_send_reply("404", "User Not Found");
		exit;
	};

	route(4);
	route(1);
}

route[4] {
	if (method=="INVITE") {
		force_rtp_proxy("","193.238.157.58");
	};
}

onreply_route {
	if (!search("^Content-Length:[ ]*0")) {
		force_rtp_proxy("","193.238.157.58");
        };
}
