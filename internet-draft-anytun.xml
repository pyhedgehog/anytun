<?xml version='1.0'?>
    <!DOCTYPE rfc SYSTEM 'rfcXXXX.dtd' [
    
    <!ENTITY rfc3068 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3068.xml'>

]>
    <rfc ipr='full3978' docName='draft-gsenger-anycast-relay-00'>
    <front>
        <title>anycast tunneling and relay protocol</title>

        <author initials='O.G.' surname='Gsenger'
                fullname='Othmar Gsenger'>
            <organization></organization>

            <address>
                <postal>
                    <street>Sporgasse 6</street>
                    <city>Graz</city>
                    <code>8010</code>
                    <country>AT</country>
                </postal>

                <phone></phone>
                <email>otti@wirdorange.org</email>
                <uri>http://anytun.org/</uri>
            </address>
        </author>

        <date month='March' year='2007' />

        <area>General</area>
        <workgroup></workgroup>
        <keyword>anytun</keyword>
        <keyword>Internet-Draft</keyword>
        <keyword>anycast tunneling / relaying</keyword>
        <keyword>tunnel</keyword>
        <keyword>relay</keyword>
        <keyword>protocol</keyword>
        <abstract>
            <t>The anycast tunneling and relay protocol (anytun) defines a protocol used for communication between unicast clients and anycast servers. It can be used for tunneling information between 2 clients over the anycast servers or in relay mode to transmit data form the client over the anycast servers to a third party not using the protocol and vice versa. Unlike other tunneling protocols like GRE or IPIP tunnels which indeed will work with anycast as well, anytun directly includes cryptography and authentication. In relay mode it also supports source NAT with integrated NAT transversal. It is intended to deliver a high performance and reliability solution for tunneling and relaying of data over servers, where direct client to client connections are not possible or not wanted.
            </t>
        </abstract>
    </front>
    <middle>
    <section title='Introduction'>
        <t>anytun defines a Host Anycast Service as defined in rfc1546. It uses a peer-to-peer achitecture, with anycast servers and unicast clients. It can be used to build high scalable and redundant tunnel services. It also has a relay mode, that makes it possible, that only one of the connection endpoints has to use the anytun protocol. This can be used to make connections through Firewalls or behind a NAT Router</t>
         <t><xref target="RFC3068">RFC3068</xref> DTD.</t>
    </section> 
    <section title="Operation modes">
       <t>This section gives an overview of possible operation modes und usage scenarios. Please note, that the protocols used in the figures are only examples and that anytun itself does not care about either transport protocols or encapsulated protocols. Routing and network address translation is not done by anytun. Each implemetation MAY choose it's own way of doing this task (e.g. using functions provided by the operating system). Anytun is used to establish and controll tunnnels, to encapsulate and encrypt data.</t>
       <section title="Usage scenarions">
    
            <section title='tunneling from unicast client over anycast servers to unicast client'>
              <figure anchor="tunnel_mode">
                 <preamble>An example of anytun used in tunnel mode</preamble>
                 <artwork>
          -----------                      ----------- 
          |   RTP   |      ----------      |   RTP   |
          -----------  ->  |server 1|  ->  -----------
          |   UDP   |      ----------      |   UDP   |
          -----------                      -----------
-----     |   IPv6  |      ----------      |   IPv6  |     -----
|   |  -> -----------  ->  |server 2|  ->  -----------  -> |   |
-----     |  anytun |      ----------      |  anytun |     -----
#####     -----------                      -----------     #####
          |   UDP   |      ----------      |   UDP   |
client 1  -----------  ->  |server 3|  ->  -----------     client 2
          |   IPv4  |      ----------      |   IPv4  |
          -----------                      -----------
          |   ...   |       anycast        |   ...   |
                 </artwork>
       </figure>
	      <t>In tunneling mode the payload of the anytun packet is transmitted from one unicast host to the anycast server. This server makes a routing descision based on the underlying protocol and transmits a new anytun package to one or more clients depending on the routing descition. The server MAY also route the packet to a directly connected network or a service running on the server, but please note, that this is only usefull for anycast host services like DNS and that the services HAVE TO be running on all servers in order to work.</t> 
	    </section>

	    <section title='tunneling from client to a server connected network'>
              <figure anchor="open_tunnel_mode">
                 <preamble>An example of anytun used in open tunnel mode</preamble>
                 <artwork>
          -----------                                 
          |   RTP   |      ----------                 
          -----------  ->  |server 1|  ->             
          |   UDP   |      ----------      -----------
          -----------                      |   RTP   |
-----     |   IPv6  |      ----------      -----------     -----
|   |  -> -----------  ->  |server 2|  ->  |   UDP*  |  -> |   |
-----     |  anytun |      ----------      -----------     -----
#####     -----------                      |   IPv6* |     #####
          |   UDP   |      ----------      -----------
client 1  -----------  ->  |server 3|  ->  |   ...   |    host
          |   IPv4  |      ----------                     not using
          -----------                                     anytun
          |   ...   |       anycast        
                                           *changed source address
                                            or port   
                 </artwork>
       </figure>

               <t>In open tunnel mode only one of two clients talking to each other over the servers MUST use the anytun protocol. When a client using the anytun protocol wants to tunnel data, it is building a connection to the anycast servers using the anytun protocol. The anycast servers relay the encapsulated packages directly to the destination without using the anytun protocol. The source address of the datagramm HAS TO be changed to the anycast address of the server. The anytun servers act like a source NAT router, therefor for the destination it saems that it is talking to the client directly.</t>
	    </section>
	</section>
	<section title="Transport modes">
      <t>Anytun does not define wich lower layer protocols HAVE TO be used, but it's most likely used on top of udp. This section should only discuss some issues on udp in combination with anycasting and tunnels.
      </t>
	  <section title="Using UDP">
              <figure anchor="transtort_udp">
                 <preamble>An example of anytun used with udp as transport</preamble>
                 <artwork>
          -----------                      -----------
          |   RTP   |      ----------      |   RTP   |
          -----------  ->  |server 1|  ->  -----------
          |   UDP   |      ----------      |   UDP   |
          -----------                      -----------
-----     |   IPv6  |      ----------      |   IPv6  |     -----
|   |  -> -----------  ->  |server 2|  ->  -----------  -> |   |
-----     |  anytun |      ----------      |  anytun |     -----
#####     -----------                      -----------     #####
          |   UDP   |      ----------      |   UDP   |
client 1  -----------  ->  |server 3|  ->  -----------     client 2
          |   IPv4  |      ----------      |   IPv4  |
          -----------                      -----------
          |   ...   |       anycast        |   ...   |
                 </artwork>
       </figure>
      <t>When using UDP no flow controll or retransmission is done, neigther by UDP nor anytun. The encapsulated protocol HAS TO take care of this tasks if needed. UDP however has a checksum of the complete udp datagram, so a packet gets discarded if there is a biterror in the payload</t>
	  </section>
	  <section title="Using lightUDP">
              <figure anchor="transport_lightudp">
                 <preamble>An example of anytun used with udp transport</preamble>
                 <artwork>
          -----------                      -----------
          |   RTP   |      ----------      |   RTP   |
          -----------  ->  |server 1|  ->  -----------
          |   UDP   |      ----------      |   UDP   |
          -----------                      -----------
-----     |   IPv6  |      ----------      |   IPv6  |     -----
|   |  -> -----------  ->  |server 2|  ->  -----------  -> |   |
-----     |  anytun |      ----------      |  anytun |     -----
#####     -----------                      -----------     #####
          |lightUDP |      ----------      |lightUDP |
client 1  -----------  ->  |server 3|  ->  -----------     client 2
          |   IPv4  |      ----------      |   IPv4  |
          -----------                      -----------
          |   ...   |       anycast        |   ...   |
                 </artwork>
       </figure>

      <t>The difference between normal UDP and lightUDP is, that the udp size is not set to the length of the full packet, but to the lenght of the data used for the checksum and therefor the checksum is only calculated for that part. When using lightUDP, the lenght HAS tO be set to the udp header length + the anytun header lenght. So there is no error correction or detection done on the payload. This can be usefull if realtime data is beeing transimittet or the tunneled protocol does error correction/detection by itself.</t>
    </section>
         <section title="Fragmentation">
         <t>
           The only way of fully supporting fragmentation would be to syncronise fragments between all anycast servers. This is considered to be to much overhead, so there are two non perfect solutions for this problems. Either fragmentation HAS TO be disabled or if not all fragments arrive at the same server the ip datagramm HAS TO be discarded. As routing changes are not expected to occure very frequently, the encapsulated protocol can do a retransmission and all fragments will arrive at the new server.
         </t>
         </section>
   </section>
     <section title="Protocol specification">
       <section title="Header format">
            <figure anchor="prot_header_table">
               <preamble>Protocol Format</preamble>
                 <artwork>
        0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |V=2|   ????????????????????    |       sequence number         | |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   | |    payload lenght             |      payload type             | |
   | |-------------------------------+-------------------------------| |
   | |              ....        payload        ...                   | |
                                     +-------------------------------+ |
   | |                               |       padding (OPTIONAL)      | |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | ~                          MKI (OPTIONAL)                       ~ |
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   | :                 authentication tag (RECOMMENDED)              : |
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
   |                                                                   |
   +- Encrypted Portion*                      Authenticated Portion ---+
</artwork>
</figure>
<t></t>
       </section>
       <section title="payload type field">
         <t>The protocol field defines the payload protocol. ETHER TYPE protocol numerbers are used. http://www.iana.org/assignments/ethernet-numbers . The values 0000-05DC are reserverd and not used at the moment. 
            <figure anchor="prot_type_table">
               <preamble>Some exmples for protocol types</preamble>
                 <artwork>
HEX
0000 Reserved
.... Reserved
05DC Reserved
0800 Internet IP (IPv4)
6558 transparent ethernet bridging
86DD IPv6
</artwork>
</figure>
</t>
     </section>
    </section>
    </section>
        <appendix title='The appan'></appendix>
    </middle>
    <back>
    <references>
        &rfc3068; An Anycast Prefix for 6to4 Relay Routers
    </references>
    </back>
    </rfc>
